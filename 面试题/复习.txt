优购在线点单系统是一个B2C模式的综合性在线销售平台。在线超市分为后台管理和前台用户两个部分；后台有商品管理模块（商
品分类、品牌管理、平台属性、SPU与SKU以及销售属性、商品上下架和评论功能等）；
前台有商品详情模块、单点登录、商品搜索、订单管理、支付功能、优惠券功能等

Linux命令
1）看日志 jps
2）查看特定行 sed -n'5,10p'
3）查看倒数1000行 tail -fn 1000
4）查看前10行 head -n 10
1.mybatis缓存机制
mybatis系统默认有两级缓存，默认情况下 只有一级缓存开启，sqlsession级别的缓存 本地缓存
二级缓存需要手动开启和配置，基于namespace级别的缓存
为了提高拓展性 mybatis定义了缓存接口cache 可通过实现cache接口自定义二级缓存

2.接口和类的区别
1）抽象类要被子类继承，接口要被类实现
2）类只能单继承，接口可以多继承接口
3）抽象类可以有构造器，接口不能有构造器
4）抽象类除了不能实例化之外，和普通Java类没区别
5）抽象方法可以有public protected default修饰，接口只能public

3.重载和重写的区别
1）重载发生在本类，重写发生在父类和子类之间
2）重载的方法名必须相同，重写的方法名相同 返回值相同
3）重载的参数列表不同，重写的参数列表相同
4）重写的访问权限不能比父类被重写的方法的访问权限更低
5）构造方法不能被重写

4.基本数据类型
1）int 整型 4字节32位 -2的31次幂到2的31次幂-1
2）long 长整型 8字节64位
3）byte 字节类型 1字节8位
4）short 短整型 2字节16位
5）float 单精度浮点型 4字节32位 小数点后6-7位
6）double 双精度浮点型 8字节64位 小数点后15-16位
7）Boolean 布尔型 1字节1位
8）char 字符型 2字节16位

5.引用数据类型
类class 数组【】接口interface 枚举enum 注解@interface

6.sleep和wait在线程里区别
sleep属于thread方法，会导致程序暂停执行指定的时间，让出cpu其他线程，保持监控状态，
时间到了之后恢复运行状态，调用过程中不会释放对象锁
wait属于object方法，调用过程会放弃对象锁，进入等待此对象的等待锁定池，让出cpu并释放占有的同步资源锁

7.==和equals区别
1）==
如果比较的是基本数据类型，比较的就是变量的值
如果比较的是引用数据类型，比较的就是地址值
2）equals
没重写就是比较两个对象地址值
重写就是比较对象中的属性值

8.final finally finalize区别
1）final 修饰类：不能派生出子类，不能被继承
	修饰变量：使用中不能被改变，声明时给定初值，作为常量不能被修改
	修饰方法：只能使用，不能在子类中被重写
2）finally 放在try catch的后面构造最终执行代码，只要jvm不关闭它的代码就能执行，可以写释放外部资源的代码
3）finalize 是object类中定义的方法，由垃圾收集器销毁对象时用的，重写这个方法可以整理系统资源

9.线程创建方法
1）继承threa类
2）实现runnable接口
3）使用线程池创建
4）使用callable和future创建

10.线程生命周期
1）新建状态new
2）就绪状态runnable
3）运行状态running
4）阻塞状态blocked
5）死亡状态dead

常见的集合底层实现
arraylist底层是数组
linkedlist底层是双向链表
hashmap底层与hashtable相同，Java8以后如果同一位置哈希冲突
hashtable底层是哈希表（数组+单项链表）
hashset底层是hashmap
linkedhashmap底层修改自hashmap，包含一个双向链表
treemap底层是linkedhashmap
treeset底层是treemap

11.常见的五个RuntimeException
1）空指针异常 java.lang.NullPointerException
2）指定的类找不到 java.lang.ClassNotFoundException
3）字符串转换位数字异常 java.lang.NumberFormatException
4）数据类型转换异常 java.lang.ClassCastException
5）方法传递参数异常 java.lang.IllegalArgumentException

12.字节流和字符流的区别
1）字节流
读到一个字节就返回一个字节，可处理所有类型的数据
主要操作byte类型数据，主要操作类是OutputStream InputStream
2）字符流
只能处理字符数据，处理纯文本用字符流，其余都是字节流
一个字符等于两个字节 主要操作类是Read Writer

13.JVM内存分区 作用
1）Java堆
被所有线程共享的内存区域，唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
虚拟机垃圾回收主要管理此区域
2）方法区
和Java堆类似，也是各个线程共享的内存区域，存储类的信息、静态变量、常量、编译后代码，
也叫永久代，很少发生垃圾回收，
3）程序计数器
是一块较小的内存空间，可以看成当前线程所执行字节码的行号指示器，是线程私有的，
唯一一个没有规定任何OOM情况的区域
4）虚拟机栈
生命周期和线程相同，线程私有，每个方法执行的时候都会创建一个栈帧，对应一个被调用的方法
，存储局部变量表、操作数栈、动态链表、方法出口
5）本地方法栈、
与虚拟机栈类似，虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机执行Native方法服务

14.堆溢出和栈溢出
1）堆溢出OOM
启动参数设置过小
代码中存在死循环或循环产生过多重复对象实体
内存加载的数据量太大，一次从数据库取出过多数据
2）栈溢出
无限递归循环调用
执行了大量方法导致线程栈空间耗尽
方法内声明了大量局部变量

15.MySQL事务
ACID
原子性：事务开始后所有操作，要么全做完 要么全不做，不可能停滞在中间环节；
	事务执行中出错 会回滚到事务开始之前，事务是个不可分割的整体
一致性：事务开始前和结束后，数据库的完整性约束没有被破坏
隔离性：同一时间只允许一个事务请求同一数据，不同事务之间互相没有干扰
持久性：事务完成后，事务对数据库的所有更新将被保存进数据库，不能回滚

16.并发问题
脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取的就是脏数据
幻读：事务A按照条件进行数据读取，期间事务B插入了相同搜索条件的新数据，
	事务A再次按照原先条件进行读取时，发现了新插入的数据
不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中对数据做了更新提交，
	导致事务A多次读取同一数据时结果不一致

17.事务隔离级别
1）串行化可以解决三种问题
2）可重复读可以解决脏读和不可重复读
3）读已提交可以解决脏读
4）读未提交可以解决

select distinct name from table where fenshu > 80

18.SpringMVC中返回json数据
1）在项目中加入json转换的依赖，如Jackson
2）在请求处理方法中将返回值改为具体返回的数据类型
3）在请求处理方法上加@ResponseBody注解

19.SpringBean的生命周期
1）调用构造器 或通过工厂的方式创建Bean对象
2）给Bean对象的属性注入值
3）调用初始化方法，进行初始化，初始化的方法是通过init-method来指定的
4）使用
5）IOC容器关闭时，销毁Bean对象

20.